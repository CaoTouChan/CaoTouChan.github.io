<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>够用就好的 Docker 教程</title>
  <meta name="description" content="核心概念">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="够用就好的 Docker 教程">
  <meta name="twitter:description" content="核心概念">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="够用就好的 Docker 教程">
  <meta property="og:description" content="核心概念">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2019/05/docker-intro/">
  <link rel="alternate" type="application/rss+xml" title="陈草头" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

  <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>

  <!-- 数学公式 -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 陈草头 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="陈草头 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for 陈草头" class="blog-button">陈草头</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">越名教而任自然</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">90 后 | 广东人 | 现居住于帝都 | 算法攻城狮</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        <!-- 
        <p class="panel-cover__description"><a href="https://caotouchan.github.io" target="_blank">我的主页</a></p>
         -->
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/lookka520" title="@lookka520 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/caotouchan" title="@caotouchan 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:caotouchan@outlook.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-red"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-05-29 14:50:01 +0800" itemprop="datePublished" class="post-meta__date date">2019-05-29</time> &#8226; <span class="post-meta__tags tags"></span>
    </div>
    <h1 class="post-title">够用就好的 Docker 教程</h1>
  </header>

  <section class="post">
    <h2 id="核心概念">核心概念</h2>

<ul>
  <li>
    <p>Docker images （镜像） ：不可变的主模板，用于抽出完全相同的容器。镜像包含应用程序需要运行的Dockerfile、库和代码。</p>
  </li>
  <li>
    <p>Dockerfile ：一个文件，其中包含Docker应如何构建映像的说明。</p>
  </li>
  <li>
    <p>Docker Container （容器）：Docker 镜像加上命令 <code class="highlighter-rouge">docker run image_name</code> 将从镜像创建并启动容器。</p>
  </li>
  <li>
    <p>Container Registry ：存储 Docker 镜像的远程位置。将镜像推送到 Registry 并从 Registry 中提取镜像。 可以托管自己的 Registry 或使用提供商的 Registry，例如 AWS 和 Google Cloud 都有 Registry。</p>
  </li>
  <li>
    <p>Engine  ：client-server app (<a href="https://docs.docker.com/install/">CE</a> or <a href="https://www.docker.com/products/docker-enterprise">Enterprise</a>)</p>
  </li>
  <li>
    <p>Client  ：处理 Docker CLI 来和 Daemon 进行交互</p>
  </li>
</ul>

<p><img src="http://www.caotouchan.tech/wp-content/uploads/2019/05/image-1559101276532.png" alt="Docker Client" /></p>

<ul>
  <li>
    <p>Daemon （守护进程）  ：侦听 Docker API 请求的 Docker 服务器，用来管理图像、容器、网络和卷。</p>
  </li>
  <li>
    <p>Volumes  （卷）：存储应用程序使用和创建的持久数据的最佳方式。</p>
  </li>
  <li>
    <p>Docker Hub  ： 默认的 Docker Registry</p>
  </li>
  <li>
    <p>Repository  ：具有相同名称和不同标记的 Docker 镜像的集合。 标签是镜像的标识符。</p>
  </li>
  <li>
    <p>Networking  ：连接容器。连接的 Docker 容器可以位于同一主机或多个主机上。 有关Docker网络的更多信息，请参阅 <a href="https://www.oreilly.com/learning/what-is-docker-networking">此文章</a>。</p>
  </li>
</ul>

<p><img src="http://www.caotouchan.tech/wp-content/uploads/2019/05/image-1559101765535.png" alt="file" /></p>

<ul>
  <li>
    <p>Compose  ：方便运行需要多个Docker容器的应用程序的工具。 Docker Compose 允许您将命令移动到 <code class="highlighter-rouge">docker-compose.yml</code> 文件中以供重用。</p>
  </li>
  <li>
    <p>Swarm  ：一个协调容器部署的产品。 参考 <a href="https://docs.docker.com/get-started/#recap-and-cheat-sheet">官方Docker教程</a> 。 推文作者建议不要花时间在Docker Swarm上，除非你有令人信服的理由这样做。</p>
  </li>
  <li>
    <p>Services  ：分布式应用程序的不同部分。Services 只运行一个映像，但它编码了映像的运行方式 ：端口、容器运行副本个数等等。Services 允许您跨多个 Docker Daemon 扩展容器，并使 Docker Swarms 成为可能。</p>
  </li>
  <li>
    <p>Kubernetes ：Kubernetes 自动化部署、扩展和管理容器化的应用程序。使用 Kubernetes 扩展具有多个 Docker 容器的项目。 （ Kubernetes 不是 Docker 的官方部分; 它更像是 Docker 的 BFF 。）</p>
  </li>
</ul>

<h2 id="dockerfile-指令">Dockerfile 指令</h2>

<p>Dockerfile 指引 Docker 构建将用于制作容器的镜像。</p>

<p>当调用 <code class="highlighter-rouge">docker build</code> 以创建镜像时，会假定 Dockerfile 位于当前工作目录中。 可以使用文件标志（<code class="highlighter-rouge">-f</code>）指定其他位置。</p>

<p>容器从一系列的 layer 中构建，<strong>除了最后一层都是只读</strong>。</p>

<p>Dockerfile 指示添加哪些层和添加的顺序。每层实际上只是一个包含自上一层以来的更改的文件。基础层（ The base image ） 包含提供初始层。</p>

<p>将映像从远程存储库提取到本地计算机时，仅下载本地计算机上尚未存在的层。</p>

<p>Dockerfile指令是一行的开头的大写单词，后跟其参数。</p>

<p>示例 Dockerfile ：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
ENV ADMIN="jeff"
RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash
COPY . ./app
ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \
/my_app_directory
RUN ["mkdir", "/a_directory"]
CMD ["python", "./my_script.py"]
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">FROM</code> : 指定 base (parent) image.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ubuntu:18.04
</code></pre></div></div>

<p>其中 <code class="highlighter-rouge">ubuntu</code> 是镜像 repository ， <code class="highlighter-rouge">18.04</code> 是标签（tag）。没有标签则拉取最新版本。</p>

<p><img src="http://www.caotouchan.tech/wp-content/uploads/2019/05/image-1559108982583.png" alt="file" /></p>

<p>创建容器时，可以在只读层的顶部添加可写层。当图像运行时，如果某个层需要由容器修改，则该文件将被复制到顶部可写层中。 了解有关 <code class="highlighter-rouge">copy-on-write</code> 的更多信息，点击 <a href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/">链接</a>。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">LABEL</code> : 提供元数据 （ metadata ）。更多信息点击 <a href="https://docs.docker.com/config/labels-custom-metadata/">链接</a>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ENV</code> : 设置持久化环境变量。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RUN</code> : 运行命令，创建镜像层。用于安装包到容器中。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">COPY</code> : 拷贝文件和目录到容器中。目标目录不存在的话会自行创建。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ADD</code> : 将文件和目录复制到容器。</p>
  </li>
</ul>

<p>和 <code class="highlighter-rouge">COPY</code> 不同的地方：
(1) 可用于将文件从远程URL移动到容器 
(2) 可以 upack 本地 的 .tar 文件。</p>

<p><code class="highlighter-rouge">ADD</code> 指令包含<code class="highlighter-rouge"> \ </code> 实现分解多行的长指令，使用它来提高可读性。</p>

<p>Docker文档不建议以这种方式使用远程URL，因为您无法删除文件。</p>

<ul>
  <li><code class="highlighter-rouge">CMD</code> : 给运行时容器提供命令和参数。</li>
</ul>

<p>只有一个 <code class="highlighter-rouge">CMD</code>。</p>

<p><code class="highlighter-rouge">CMD</code> 可以包含可执行文件。 如果 <code class="highlighter-rouge">CMD</code> 不存在可执行文件，则必须存在 <code class="highlighter-rouge">ENTRYPOINT</code> 指令。 在这种情况下，<code class="highlighter-rouge">CMD</code> 和 <code class="highlighter-rouge">ENTRYPOINT</code> 指令都应采用JSON格式。</p>

<p>docker 的命令行参数运行<strong>覆盖</strong> Dockerfile 中提供给 <code class="highlighter-rouge">CMD</code> 的参数。</p>

<p>以下是另一个示例 Dockerfile：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
## Install dependencies
RUN apk add --update git
## Set current working directory
WORKDIR /usr/src/my_app_directory
## Copy code from your local context to the image working directory
COPY . .
## Set default value for a variable
ARG my_var=my_default_value
## Set code to run at container run time
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
## Expose our port to the world
EXPOSE 8000
## Create a volume for data storage
VOLUME /my_volume
</code></pre></div></div>

<p>有几种方法可以使用 <code class="highlighter-rouge">RUN</code> 安装软件包：</p>

<ol>
  <li>使用<code class="highlighter-rouge">apk</code>在 Alpine Docker 映像中安装软件包。 具有基本 Ubuntu 映像的 Dockerfile 中的包可以像这样更新和安装：<code class="highlighter-rouge">RUN apt-get update &amp;&amp; apt-get install my_package</code>。</li>
  <li>通过<code class="highlighter-rouge">pip</code>，<code class="highlighter-rouge">wheel</code>和<code class="highlighter-rouge">conda</code>安装 Python 包。其他语言可以使用各种安装程序。（请确保在尝试使用包管理器之前安装包管理器）请使用 ` \ ` 拆分多行。</li>
  <li>在文件中列出包需求，通常将文件命名为 <strong>requirements.txt</strong>。下文将分享一个推荐的模式使用 requirements.txt 来利用构建时缓存。</li>
</ol>

<ul>
  <li><code class="highlighter-rouge">WORKDIR</code> : 设置后续指令的工作目录。</li>
</ul>

<ol>
  <li>
    <p>最好使用 <code class="highlighter-rouge">WORKDIR</code> 设置绝对路径，而不是使用Dockerfile中的cd命令浏览文件系统。</p>
  </li>
  <li>
    <p>如果目录不存在， <code class="highlighter-rouge">WORKDIR</code> 会自动创建目录。</p>
  </li>
  <li>
    <p>可以使用多个 <code class="highlighter-rouge">WORKDIR</code> 指令。 如果提供了相对路径，则每个 <code class="highlighter-rouge">WORKDIR</code> 指令都会更改当前工作目录。</p>
  </li>
</ol>

<ul>
  <li><code class="highlighter-rouge">ARG</code> : 定义一个在构建时传递给 Docker 的变量。</li>
</ul>

<p>与 <code class="highlighter-rouge">ENV</code> 变量不同，<code class="highlighter-rouge">ARG</code> 变量不可用于运行容器。 但是，在构建映像时，可以使用 <code class="highlighter-rouge">ARG</code> 值从命令行设置 <code class="highlighter-rouge">ENV</code> 变量的默认值。 然后，<code class="highlighter-rouge">ENV</code> 变量在容器运行时间内持续存在。 在 <a href="https://vsupalov.com/docker-build-time-env-values/">此处</a> 详细了解此技术。</p>

<ul>
  <li><code class="highlighter-rouge">ENTRYPOINT</code> : 在容器启动时提供默认命令和参数。</li>
</ul>

<p>类似于<code class="highlighter-rouge">CMD</code>，但如果使用命令行参数运行容器，则不会覆盖<code class="highlighter-rouge">ENTRYPOINT</code>参数。相反，<strong>传递给 <code class="highlighter-rouge">docker run my_image_name</code> 的命令行参数会附加到 <code class="highlighter-rouge">ENTRYPOINT</code> 指令的参数中</strong>。例如，<code class="highlighter-rouge">docker run my_image bash</code> 将参数<code class="highlighter-rouge">bash</code> 添加到<code class="highlighter-rouge">ENTRYPOINT</code> 指令的现有参数的末尾。</p>

<p>Dockerfile至少应有一条<code class="highlighter-rouge">CMD</code>或<code class="highlighter-rouge">ENTRYPOINT</code>指令。<code class="highlighter-rouge">CMD</code> 和<code class="highlighter-rouge">ENTRYPOINT</code>之间进行选择的建议：</p>

<ol>
  <li>每次需要运行相同的命令时，请关注<code class="highlighter-rouge">ENTRYPOINT</code>。</li>
  <li>当容器将用作可执行程序时，请关注<code class="highlighter-rouge">ENTRYPOINT</code>。</li>
  <li>当您需要提供可以从命令行覆盖的额外默认参数时，请支持<code class="highlighter-rouge">CMD</code>。</li>
</ol>

<ul>
  <li><code class="highlighter-rouge">EXPOSE</code> : 显示要发布的端口，以提供对正在运行的容器的访问。</li>
</ul>

<p><code class="highlighter-rouge">EXPOSE</code> 实际上并不发布端口。 相反，它充当构建镜像的人和运行容器的人之间的文档。</p>

<p>使用带有<code class="highlighter-rouge">-p</code> 标志的 <code class="highlighter-rouge">docker run</code> 可以在运行时发布和映射一个或多个端口。 大写的 <code class="highlighter-rouge">-P</code> 标志将发布所有暴露的端口。</p>

<ul>
  <li><code class="highlighter-rouge">VOLUME</code> : 创建目录挂载点以访问和存储持久化数据。</li>
</ul>

<p>另外，关于 Dockerfile 的小抄，请点击 <a href="https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index">此链接</a>。</p>

<h2 id="压缩-docker-镜像">压缩 Docker 镜像</h2>

<h3 id="缓存">缓存</h3>

<p>在检查每条指令时，Docker在其缓存中查找现有的中间镜像，它可以重复使用而不是创建新的（重复的）中间镜像。</p>

<p>大多数新指令只是与中间镜像中的指令进行比较。如果匹配，则使用缓存副本。</p>

<p>一些实用缓存的建议：</p>

<ul>
  <li>通过使用 <code class="highlighter-rouge">docker build</code> 传递 ` –no-cache = True` 可以关闭缓存。</li>
  <li>将可能更改的指令放在Dockerfile中尽可能低的位置。</li>
  <li>链式的 <code class="highlighter-rouge">RUN apt-get update</code> 和 <code class="highlighter-rouge">apt-get install</code> 命令可避免缓存缺失问题。</li>
  <li>如果使用包装安装程序（如<code class="highlighter-rouge">pip</code>和 requirements.txt 文件），请按照下面的模型进行操作，以确保没有收到带有 requirements.txt 中列出的旧包的旧版本中间镜像。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COPY requirements.txt /tmp/
RUN pip install -r /tmp/requirements.txt
COPY . /tmp/
</code></pre></div></div>

<h3 id="size-reduction">Size Reduction</h3>

<p>Alpine基础映像是一个完整的Linux发行版，没有太多其他内容。 下载通常不到5mb，但它要求您花更多的时间编写构建工作应用程序所需的依赖项的代码。</p>

<p>如果你的容器中需要Python，那么Python Alpine构建是一个很好的折衷方案。</p>

<h3 id="多阶段构建">多阶段构建</h3>

<p>多级构建使用多个 <code class="highlighter-rouge">FROM</code> 指令，每个 <code class="highlighter-rouge">FROM</code> 指令：</p>

<ol>
  <li>begins a new stage of the build.</li>
  <li>leaves behind any state created in prior stages.</li>
  <li>can use a different base.</li>
</ol>

<p>多阶段构建示例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM golang:1.7.3 AS build
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=build /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]
</code></pre></div></div>

<p>通过在 <code class="highlighter-rouge">FROM</code> 指令中附加名称来命名第一个阶段。 然后在 Dockerfile 中的 <code class="highlighter-rouge">COPY --from =</code> 指令中引用指定的阶段。</p>

<p>有时多级构建会增加更多复杂性，使图像难以维护，因此您可能不会在大多数构建中使用它们。 请参阅进一步讨论：<a href="https://blog.realkinetic.com/building-minimal-docker-containers-for-python-applications-37d0272c52f3">权衡</a> 和 <a href="https://medium.com/@tonistiigi/advanced-multi-stage-build-patterns-6f741b852fae">高阶模式</a> 。</p>

<h3 id="dockerignore">.dockerignore</h3>

<p>.dockerignore类似于.gitignore，其中包含Docker与文件名匹配的模式列表，并在制作镜像时排除。</p>

<p>使用 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match">filepath.Match 规则</a>  和一些 <a href="https://docs.docker.com/v17.09/engine/reference/builder/#dockerignore-file">Docker 自身的规则</a>。</p>

<h3 id="size-inspection">Size Inspection</h3>

<ul>
  <li>
    <p>查看正在运行的容器大小： <code class="highlighter-rouge">docker container ls -s</code></p>
  </li>
  <li>
    <p>显示镜像的大小： <code class="highlighter-rouge">docker image ls</code></p>
  </li>
  <li>
    <p>查看中间镜像的大小：<code class="highlighter-rouge">docker image history my_image：my_tag</code></p>
  </li>
  <li>
    <p>运行 <code class="highlighter-rouge">docker image inspect my_image</code>：tag将显示有关镜像的许多内容，包括每个 layer 的大小。layer 和中间镜像的复杂性，查看Nigel Brown的 <a href="https://windsock.io/explaining-docker-image-ids/">这篇文章</a>。</p>
  </li>
  <li>
    <p>安装和使用 <a href="https://github.com/wagoodman/dive">dive</a> 可以轻松查看 layer 的内容。</p>
  </li>
</ul>

<h3 id="几个实用的建议">几个实用的建议</h3>

<ol>
  <li>尽可能使用官方的 base image。</li>
  <li>尽可能使用 Alpine 镜像的变体来保持镜像的量级。</li>
  <li>如果使用 <code class="highlighter-rouge">apt</code>，在同一指令中将 <code class="highlighter-rouge">RUN apt-get update</code>与 <code class="highlighter-rouge">apt-get install</code> 结合使用（减少了构建的层数），如：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUN apt-get update &amp;&amp; apt-get install -y \
 package-one \
 package-two 
 &amp;&amp; rm -rf /var/lib/apt/lists/*
</code></pre></div>    </div>
  </li>
  <li>
    <p>在 <code class="highlighter-rouge">RUN</code> 指令的末尾包含 <code class="highlighter-rouge">&amp;&amp; rm -rf / var / lib / apt / lists / *</code> 以清理 <code class="highlighter-rouge">apt</code> 缓存，使其不存储在层中。</p>
  </li>
  <li>
    <p>通过在 Dockerfile 中放置可能更改的指令，明智地使用缓存。</p>
  </li>
  <li>
    <p>使用 .dockerignore 文件。</p>
  </li>
  <li>
    <p>使用 <a href="https://github.com/wagoodman/dive">dive</a> 检查 Docker 镜像层方便压缩规模。</p>
  </li>
  <li>不要安装不需要的包。（- ，- b）</li>
</ol>

<h2 id="常用命令">常用命令</h2>

<h3 id="containers">Containers</h3>
<p>Use <code class="highlighter-rouge">docker container my_command</code></p>

<p><code class="highlighter-rouge">create</code> — Create a container from an image.</p>

<p><code class="highlighter-rouge">start </code>— Start an existing container.</p>

<p><code class="highlighter-rouge">run </code>— Create a new container and start it.</p>

<p><code class="highlighter-rouge">ls</code> — List running containers.</p>

<p><code class="highlighter-rouge">inspect </code>— See lots of info about a container.</p>

<p><code class="highlighter-rouge">logs </code>— Print logs.</p>

<p><code class="highlighter-rouge">stop</code> — Gracefully stop running container.</p>

<p><code class="highlighter-rouge">kill</code> —Stop main process in container abruptly.</p>

<p><code class="highlighter-rouge">rm</code>— Delete a stopped container.</p>

<h3 id="images">Images</h3>
<p>Use <code class="highlighter-rouge">docker image my_command</code></p>

<p><code class="highlighter-rouge">build </code>— Build an image.</p>

<p><code class="highlighter-rouge">push </code>— Push an image to a remote registry.</p>

<p><code class="highlighter-rouge">ls </code>— List images.</p>

<p><code class="highlighter-rouge">history</code> — See intermediate image info.</p>

<p><code class="highlighter-rouge">inspect </code>— See lots of info about an image, including the layers.</p>

<p><code class="highlighter-rouge">rm </code>— Delete an image.</p>

<h3 id="misc">Misc</h3>

<p><code class="highlighter-rouge">docker version</code> — List info about your Docker Client and Server versions.</p>

<p><code class="highlighter-rouge">docker login </code>— Log in to a Docker registry.</p>

<p><code class="highlighter-rouge">docker system prune </code>— Delete all unused containers, unused networks, and dangling images.</p>

<h2 id="卷volumedocker-中的数据">卷（Volume）：Docker 中的数据</h2>

<h3 id="临时数据">临时数据</h3>

<p>通过两种方式临时保存文件：</p>

<ol>
  <li>
    <p>默认情况下，容器内应用程序创建的文件存储在容器的可写层中。当容器不再存在时，数据也将消失。</p>
  </li>
  <li>
    <p>保存临时数据同时具有更好的性能：<code class="highlighter-rouge">tmpfs mount</code> 使用主机内存进行临时挂载，具有更快的读写操作的优点。</p>
  </li>
</ol>

<h3 id="持久化数据">持久化数据</h3>

<p>两种持久化数据的方式：</p>

<ol>
  <li>将文件系统挂载到容器。使用绑定装载，Docker外部的进程也可以修改数据。绑定挂载很难备份，迁移或与其他Container共享。</li>
</ol>

<p><img src="http://www.caotouchan.tech/wp-content/uploads/2019/05/image-1559117952332.png" alt="file" /></p>

<ol>
  <li>使用卷（Volume）保存数据是更好的方法。</li>
</ol>

<h3 id="卷">卷</h3>

<p>卷是一个文件系统，它位于任何容器之外的主机上。 卷由Docker创建和管理。 卷的特性：</p>

<ul>
  <li>
    <p>持久化</p>
  </li>
  <li>
    <p>自由浮动的文件系统，与任何一个容器分开</p>
  </li>
  <li>
    <p>与其他容器共用</p>
  </li>
  <li>
    <p>高效的输入和输出</p>
  </li>
  <li>
    <p>能够托管在远程云提供商上</p>
  </li>
  <li>
    <p>可加密</p>
  </li>
  <li>
    <p>可命名</p>
  </li>
  <li>
    <p>能够通过容器预先填充其内容</p>
  </li>
  <li>
    <p>方便测试</p>
  </li>
</ul>

<h3 id="创建卷">创建卷</h3>

<p>通过 Dockerfile 或 API 请求创建卷。</p>

<p><code class="highlighter-rouge">VOLUME / my_volume</code></p>

<p>使用Dockerfile创建卷，则仍需要在运行时声明卷的安装点。</p>

<p>还可以使用JSON数组格式在 Dockerfile 中创建卷。</p>

<p>卷也可以在运行时从命令行实例化。</p>

<h3 id="volume-cli-命令">Volume CLI 命令</h3>

<p>常用的命令：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">docker volume create —-name my_volume</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">docker volume ls</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">docker volume inspect my_volume</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">docker volume rm my_volume</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">docker volume prune</code></p>
  </li>
</ul>

<p>docker run中的–mount标志的常用选项 -  mount my_options my_image：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">type=volume</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">source=volume_name</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">destination=/path/in/container</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">readonly</code></p>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]. <a href="https://medium.com/search?q=Learn%20Enough%20Docker%20to%20be%20Useful">Learn Enough Docker to be Useful</a></p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2019/06/ES-intro/" title="link to Elasticsearch 实战（01）综述">Elasticsearch 实战（01）综述</a></h2>
       <p class="excerpt">综述Elasticsearch 是一个分布式搜索引擎，可以实现大数据近实时分析，其高性能和易扩展、易使用性受到众多公司的青睐。这个系列文章基于 Elasticsearch 7.0 进行探索和实践，参考 极客时间的 《 Elasticsearch核心技术与实战 》 系列专栏。分布式架构集群规模可以从单个扩展到数百个节点，从服务和数据两个维度实现高可用和水平拓展。 ES 支持不用的节点类型，支持 Hot &amp; Warm 架构。集成方式      支持多种编程语言类库，如 Java/.NE...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-06-26 18:46:01 +0800" class="post-list__meta--date date">2019-06-26</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2019/06/ES-intro/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2019/05/struc-04/" title="link to 结构化学习（4）：序列标记（ Sequence Labeling ）">结构化学习（4）：序列标记（ Sequence Labeling ）</a></h2>
       <p class="excerpt">概述序列标记问题，是一个序列到另一个序列的映射，表达为下式：序列标记有很多应用，比如 POS tagging、Morphosyntactic Attributes、Named Entity Recognition、Tokenization、Code switching 和 Dialogue acts 等。以 POS tagging 为例，如下：Hidden Markov Model (HMM)生成句子的步骤我们如何生成一个句子呢？考虑以下步骤：  根据语法生成 POS 序列  根据 POS...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-05-27 14:50:01 +0800" class="post-list__meta--date date">2019-05-27</time> &#8226; <span class="post-list__meta--tags tags"></span><a class="btn-border-small" href=/2019/05/struc-04/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  

  

  <!-- Gitalk 评论 start  -->
  
    <!-- Link Gitalk 的支持文件  -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

    <div id="gitalk-container"></div>

    <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '6005df5e831456f4482b',
        clientSecret: 'ffc57d242198e14cdb68b7457a765d0b719415fb',
        repo: 'caotouchan.github.io',
        owner: 'CaoTouChan',
        admin: ['CaoTouChan'],
        id: window.location.pathname,
      });
      gitalk.render('gitalk-container');
    </script>
  
  <!-- Gitalk end -->
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="https://caotouchan.github.io">@caotouchan</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/CaoTouChan/caotouchan.github.io">本站源码</a> - &copy; 2019</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
